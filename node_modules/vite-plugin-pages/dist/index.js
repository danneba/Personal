"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv) => {
      argv = argv || process.argv;
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const pos = argv.indexOf(prefix + flag);
      const terminatorPos = argv.indexOf("--");
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      const min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util = __require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/debug@4.3.2/node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node();
    }
  }
});

// src/generate.ts
var _path = require('path');

// src/utils.ts
var import_debug = __toModule(require_src());
var _fs = require('fs'); var _fs2 = _interopRequireDefault(_fs);

var _deepequal = require('deep-equal'); var _deepequal2 = _interopRequireDefault(_deepequal);
var _utils = require('@antfu/utils');

// src/parser.ts
var _compilersfc = require('@vue/compiler-sfc');
var _json5 = require('json5'); var _json52 = _interopRequireDefault(_json5);
var _yaml = require('yaml'); var _yaml2 = _interopRequireDefault(_yaml);
function parseSFC(code) {
  try {
    return _compilersfc.parse.call(void 0, code, {
      pad: "space"
    }).descriptor;
  } catch (e) {
    throw new Error(`[vite-plugin-pages] Vue3's "@vue/compiler-sfc" is required.`);
  }
}
function parseCustomBlock(block, filePath, options) {
  var _a;
  const lang = (_a = block.lang) != null ? _a : options.routeBlockLang;
  if (lang === "json5") {
    try {
      return _json52.default.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  } else if (lang === "json") {
    try {
      return JSON.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      return _yaml2.default.parse(block.content);
    } catch (err) {
      throw new Error(`Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`);
    }
  }
}

// src/constants.ts
var MODULE_IDS = ["pages-generated", "virtual:generated-pages", "virtual:generated-pages-react"];
var MODULE_ID_VIRTUAL = "/@vite-plugin-pages/generated-pages";

// src/utils.ts
var routeBlockCache = new Map();
function extensionsToGlob(extensions) {
  return extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0] || "";
}
function isPagesDir(path, options) {
  for (const page of options.pagesDir) {
    const dirPath = _utils.slash.call(void 0, _path.resolve.call(void 0, options.root, page.dir));
    if (path.startsWith(dirPath))
      return true;
  }
  return false;
}
function isTarget(path, options) {
  return isPagesDir(path, options) && options.extensionsRE.test(path);
}
var debug = {
  hmr: (0, import_debug.default)("vite-plugin-pages:hmr"),
  parser: (0, import_debug.default)("vite-plugin-pages:parser"),
  gen: (0, import_debug.default)("vite-plugin-pages:gen"),
  options: (0, import_debug.default)("vite-plugin-pages:options"),
  cache: (0, import_debug.default)("vite-plugin-pages:cache"),
  pages: (0, import_debug.default)("vite-plugin-pages:pages")
};
var dynamicRouteRE = /^\[.+\]$/;
var nuxtDynamicRouteRE = /^_[\s\S]*$/;
function isDynamicRoute(routePath, nuxtStyle = false) {
  return nuxtStyle ? nuxtDynamicRouteRE.test(routePath) : dynamicRouteRE.test(routePath);
}
function isCatchAllRoute(routePath, nuxtStyle = false) {
  return nuxtStyle ? /^_$/.test(routePath) : /^\[\.{3}/.test(routePath);
}
function resolveImportMode(filepath, options) {
  const mode = options.importMode;
  if (typeof mode === "function")
    return mode(filepath);
  for (const pageDir of options.pagesDir) {
    if (options.syncIndex && pageDir.baseRoute === "" && filepath === `/${pageDir.dir}/index.vue`)
      return "sync";
  }
  return mode;
}
function pathToName(filepath) {
  return filepath.replace(/[_.\-\\/]/g, "_").replace(/[[:\]()]/g, "$");
}
function getRouteBlock(path, options) {
  const content = _fs2.default.readFileSync(path, "utf8");
  const parsed = parseSFC(content);
  const blockStr = parsed.customBlocks.find((b) => b.type === "route");
  if (!blockStr)
    return null;
  const result = parseCustomBlock(blockStr, path, options);
  debug.parser("%s: %O", path, result);
  routeBlockCache.set(_utils.slash.call(void 0, path), result);
  return result;
}
function getPagesVirtualModule(server) {
  const { moduleGraph } = server;
  const module = moduleGraph.getModuleById(MODULE_ID_VIRTUAL);
  if (module) {
    moduleGraph.invalidateModule(module);
    return module;
  }
  return null;
}
function replaceSquareBrackets(bundle) {
  const files = Object.keys(bundle).map((i) => _path.basename.call(void 0, i));
  for (const chunk of Object.values(bundle)) {
    chunk.fileName = chunk.fileName.replace(/(\[|\])/g, "_");
    if (chunk.type === "chunk") {
      for (const file of files)
        chunk.code = chunk.code.replace(file, file.replace(/(\[|\])/g, "_"));
    }
  }
}
function isRouteBlockChanged(filePath, options) {
  debug.cache(routeBlockCache);
  const oldRouteBlock = routeBlockCache.get(filePath);
  const routeBlock = getRouteBlock(filePath, options);
  debug.hmr("%s old: %O", filePath, oldRouteBlock);
  debug.hmr("%s new: %O", filePath, routeBlock);
  return !_deepequal2.default.call(void 0, oldRouteBlock, routeBlock);
}

// src/stringify.ts
var componentRE = /"component":("(.*?)")/g;
var hasFunctionRE = /"(?:props|beforeEnter)":("(.*?)")/g;
function replaceFunction(_, value) {
  if (value instanceof Function || typeof value === "function") {
    const fnBody = value.toString().replace(/(\t|\n|\r|\s)/g, "");
    if (fnBody.length < 8 || fnBody.substring(0, 8) !== "function")
      return `_NuFrRa_${fnBody}`;
    return fnBody;
  }
  return value;
}
function stringifyRoutes(preparedRoutes, options) {
  const imports = [];
  function componentReplacer(str, replaceStr, path) {
    const mode = resolveImportMode(path, options);
    if (mode === "sync") {
      const importName = pathToName(path);
      const importStr = `import ${importName} from '${path}'`;
      if (!imports.includes(importStr))
        imports.push(importStr);
      return str.replace(replaceStr, importName);
    } else {
      return str.replace(replaceStr, `() => import('${path}')`);
    }
  }
  function functionReplacer(str, replaceStr, content) {
    if (content.startsWith("function"))
      return str.replace(replaceStr, content);
    if (content.startsWith("_NuFrRa_"))
      return str.replace(replaceStr, content.slice(8));
    return str;
  }
  const stringRoutes = JSON.stringify(preparedRoutes, replaceFunction).replace(componentRE, componentReplacer).replace(hasFunctionRE, functionReplacer);
  return {
    imports,
    stringRoutes
  };
}

// src/generate.ts
function prepareRoutes(routes, options, parent) {
  var _a;
  for (const route of routes) {
    if (route.name)
      route.name = route.name.replace(/-index$/, "");
    if (parent)
      route.path = route.path.replace(/^\//, "");
    if (!options.react)
      route.props = true;
    if (options.react) {
      delete route.name;
      route.routes = route.children;
      delete route.children;
      route.exact = true;
    }
    if (route.children) {
      delete route.name;
      route.children = prepareRoutes(route.children, options, route);
    }
    if (!options.react)
      Object.assign(route, route.customBlock || {});
    delete route.customBlock;
    Object.assign(route, ((_a = options.extendRoute) == null ? void 0 : _a.call(options, route, parent)) || {});
  }
  return routes;
}
function generateRoutes(pages, options) {
  const {
    nuxtStyle
  } = options;
  const routes = [];
  pages.forEach((page) => {
    const pathNodes = page.route.split("/");
    const component = `/${page.component}`;
    const route = {
      name: "",
      path: "",
      component,
      customBlock: page.customBlock
    };
    let parentRoutes = routes;
    for (let i = 0; i < pathNodes.length; i++) {
      const node = pathNodes[i];
      const isDynamic = isDynamicRoute(node, nuxtStyle);
      const isCatchAll = isCatchAllRoute(node, nuxtStyle);
      const normalizedName = isDynamic ? nuxtStyle ? isCatchAll ? "all" : node.replace(/^_/, "") : node.replace(/^\[(\.{3})?/, "").replace(/\]$/, "") : node;
      const normalizedPath = normalizedName.toLowerCase();
      route.name += route.name ? `-${normalizedName}` : normalizedName;
      const parent = parentRoutes.find((node2) => node2.name === route.name);
      if (parent) {
        parent.children = parent.children || [];
        parentRoutes = parent.children;
        route.path = "";
      } else if (normalizedName === "index" && !route.path) {
        route.path += "/";
      } else if (normalizedName !== "index") {
        if (isDynamic) {
          route.path += `/:${normalizedName}`;
          if (isCatchAll)
            route.path += "(.*)*";
        } else {
          route.path += `/${normalizedPath}`;
        }
      }
    }
    parentRoutes.push(route);
  });
  const preparedRoutes = prepareRoutes(routes, options);
  let finalRoutes = preparedRoutes.sort((i) => i.path.includes(":") ? 1 : -1);
  const allRoute = finalRoutes.find((i) => isCatchAllRoute(_path.basename.call(void 0, i.component)));
  if (allRoute) {
    finalRoutes = finalRoutes.filter((i) => !isCatchAllRoute(_path.basename.call(void 0, i.component)));
    finalRoutes.push(allRoute);
  }
  return finalRoutes;
}
function generateClientCode(routes, options) {
  const { imports, stringRoutes } = stringifyRoutes(routes, options);
  return `${imports.join("\n")}

const routes = ${stringRoutes}

export default routes`;
}

// src/options.ts


// src/files.ts
var _fastglob = require('fast-glob'); var _fastglob2 = _interopRequireDefault(_fastglob);
function getIgnore(exclude) {
  return ["node_modules", ".git", "**/__*__/**", ...exclude];
}
function getPageDirs(pageDirOptions, root, exclude) {
  const dirs = _fastglob2.default.sync(pageDirOptions.dir, {
    ignore: getIgnore(exclude),
    onlyDirectories: true,
    dot: true,
    unique: true,
    cwd: root
  });
  const pageDirs = dirs.map((dir) => __spreadProps(__spreadValues({}, pageDirOptions), {
    dir
  }));
  return pageDirs;
}
function getPageFiles(path, options) {
  const {
    exclude,
    extensions
  } = options;
  const ext = extensionsToGlob(extensions);
  const files = _fastglob2.default.sync(`**/*.${ext}`, {
    ignore: getIgnore(exclude),
    onlyFiles: true,
    cwd: path
  });
  return files;
}

// src/options.ts
function resolvePageDirs(pagesDir, root, exclude) {
  pagesDir = _utils.toArray.call(void 0, pagesDir);
  return pagesDir.flatMap((pagesDir2) => {
    const option = typeof pagesDir2 === "string" ? { dir: pagesDir2, baseRoute: "" } : pagesDir2;
    option.dir = _utils.slash.call(void 0, _path.resolve.call(void 0, root, option.dir)).replace(`${root}/`, "");
    option.baseRoute = option.baseRoute.replace(/^\//, "").replace(/\/$/, "");
    return getPageDirs(option, root, exclude);
  });
}
function resolveOptions(userOptions, viteRoot) {
  const {
    pagesDir = ["src/pages"],
    routeBlockLang = "json5",
    exclude = [],
    syncIndex = true,
    replaceSquareBrackets: replaceSquareBrackets2 = false,
    nuxtStyle = false,
    react = false,
    extendRoute,
    onRoutesGenerated,
    onClientGenerated
  } = userOptions;
  const root = viteRoot || _utils.slash.call(void 0, process.cwd());
  const importMode = userOptions.importMode || (react ? "sync" : "async");
  const extensions = userOptions.extensions || (react ? ["tsx", "jsx"] : ["vue", "ts", "js"]);
  const extensionsRE = new RegExp(`\\.(${extensions.join("|")})$`);
  const resolvedPagesDir = resolvePageDirs(pagesDir, root, exclude);
  const resolvedOptions = {
    pagesDir: resolvedPagesDir,
    routeBlockLang,
    root,
    extensions,
    importMode,
    exclude,
    syncIndex,
    replaceSquareBrackets: replaceSquareBrackets2,
    nuxtStyle,
    react,
    extensionsRE,
    extendRoute,
    onRoutesGenerated,
    onClientGenerated
  };
  return resolvedOptions;
}

// src/pages.ts

function removePage(pages, file) {
  pages.delete(file);
}
function updatePage(pages, file) {
  const page = pages.get(file);
  if (page) {
    const customBlock = routeBlockCache.get(file) || null;
    page.customBlock = customBlock;
    pages.delete(file);
    pages.set(file, page);
  }
}
function addPage(pages, file, options) {
  file = file.replace(options.root, "");
  const pageDir = options.pagesDir.find((i) => file.startsWith(`/${i.dir}`));
  if (!pageDir)
    return;
  setPage(pages, pageDir, file.replace(`/${pageDir.dir}/`, ""), options);
}
function resolvePages(options) {
  const dirs = _utils.toArray.call(void 0, options.pagesDir);
  const pages = new Map();
  const pageDirFiles = dirs.map((pageDir) => {
    const pagePath = _utils.slash.call(void 0, _path.resolve.call(void 0, options.root, pageDir.dir));
    return __spreadProps(__spreadValues({}, pageDir), {
      files: getPageFiles(pagePath, options)
    });
  });
  for (const pageDir of pageDirFiles) {
    pageDir.files.forEach((file) => {
      setPage(pages, pageDir, file, options);
    });
  }
  const routes = [];
  for (const page of pages.values()) {
    if (!routes.includes(page.route))
      routes.push(page.route);
    else
      throw new Error(`[vite-plugin-pages] duplicate route in ${page.filepath}`);
  }
  return pages;
}
function setPage(pages, pageDir, file, options) {
  const component = _utils.slash.call(void 0, _path.join.call(void 0, pageDir.dir, file));
  const filepath = _utils.slash.call(void 0, _path.resolve.call(void 0, options.root, component));
  const extension = _path.extname.call(void 0, file).slice(1);
  const customBlock = ["vue", "md"].includes(extension) ? getRouteBlock(filepath, options) : null;
  pages.set(filepath, {
    dir: pageDir.dir,
    route: _utils.slash.call(void 0, _path.join.call(void 0, pageDir.baseRoute, file.replace(options.extensionsRE, ""))),
    extension,
    filepath,
    component,
    customBlock
  });
}

// src/hmr.ts
function handleHMR(server, pages, options, clearRoutes) {
  const { ws, watcher } = server;
  function fullReload() {
    getPagesVirtualModule(server);
    clearRoutes();
    ws.send({
      type: "full-reload"
    });
  }
  watcher.on("add", (file) => {
    const path = _utils.slash.call(void 0, file);
    if (isTarget(path, options)) {
      addPage(pages, path, options);
      debug.hmr("add", path);
      fullReload();
    }
  });
  watcher.on("unlink", (file) => {
    const path = _utils.slash.call(void 0, file);
    if (isTarget(path, options)) {
      removePage(pages, path);
      debug.hmr("remove", path);
      fullReload();
    }
  });
  watcher.on("change", (file) => {
    const path = _utils.slash.call(void 0, file);
    if (isTarget(path, options) && !options.react) {
      const needReload = isRouteBlockChanged(path, options);
      if (needReload) {
        updatePage(pages, path);
        debug.hmr("change", path);
        fullReload();
      }
    }
  });
}

// src/index.ts
function pagesPlugin(userOptions = {}) {
  let generatedRoutes = null;
  let options;
  let pages;
  return {
    name: "vite-plugin-pages",
    enforce: "pre",
    configResolved({ root }) {
      options = resolveOptions(userOptions, root);
      pages = resolvePages(options);
      debug.options(options);
      debug.pages(pages);
    },
    configureServer(server) {
      handleHMR(server, pages, options, () => {
        generatedRoutes = null;
      });
    },
    resolveId(id) {
      return MODULE_IDS.includes(id) || MODULE_IDS.some((i) => id.startsWith(i)) ? MODULE_ID_VIRTUAL : null;
    },
    async load(id) {
      var _a, _b;
      if (id !== MODULE_ID_VIRTUAL)
        return;
      if (!generatedRoutes) {
        generatedRoutes = [];
        generatedRoutes = generateRoutes(pages, options);
        generatedRoutes = await ((_a = options.onRoutesGenerated) == null ? void 0 : _a.call(options, generatedRoutes)) || generatedRoutes;
      }
      debug.gen("routes: %O", generatedRoutes);
      let clientCode = generateClientCode(generatedRoutes, options);
      clientCode = await ((_b = options.onClientGenerated) == null ? void 0 : _b.call(options, clientCode)) || clientCode;
      return clientCode;
    },
    async transform(_code, id) {
      if (!/vue&type=route/.test(id))
        return;
      return {
        code: "export default {}",
        map: null
      };
    },
    generateBundle(_options, bundle) {
      if (options.replaceSquareBrackets)
        replaceSquareBrackets(bundle);
    }
  };
}
var src_default = pagesPlugin;



exports.default = src_default; exports.generateRoutes = generateRoutes;
